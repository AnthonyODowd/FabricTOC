# Identity and Chains of Trust

Identities really matter in a Hyperledger Fabric blockchain network! That's because a principal's **identity determines the exact permissions over resources in a blockchain network**. As well as **verifying** the information in a digital certificate, network resources who use a principal's identity also have to **recognize** the source of that trusted information. These two concepts -- verification and recognition -- are provided by **Certificate Authorities** and **Membership Service Providers** respectively. When combined they create the **trusted identities** in a blockchain network.

**You'll find the idea of a trusted identity easiest to understand if you start with an analogy.** Imagine that you visit a supermarket to buy some groceries. At the checkout you see a sign that says that only Visa, Mastercard and AMEX cards are accepted. If you try to pay with a different card -- let's call it an "ImagineCard" -- it doesn't matter whether the card is authentic and you have sufficient funds. It will be denied.

CAs and MSPs provide this combination of verification and recognition. The CA is like the card provider -- it dispenses verifiable identities. The MSP on the other hand is like the list of valid card providers accepted by the store -- determining which identities are valid to do the things the holders of those identities want to do.

Let's drill into these concepts in a little more detail.

## What is a Certificate Authority?

As you've seen, an identity is brought to the blockchain network by a principal in the form of a cryptographically validated digital certificate issued by a Certificate Authority (CA). CAs are a common part of internet security protocols, and you've probably heard of some of the more popular ones: Symantec (originally Verisign), GeoTrust, DigiCert, GoDaddy, and Comodo, among others.  

The digital certificate provided by a CA for a principal incorporates the principal's public key as well as a comprehensive set of their attributes. Crucially, CAs themselves also have a certificate, which they make widely available. This allows the consumers of identities issued by a given CA to easily verify them by checking that the certificate could only have been generated by the holder of the corresponding private key (the CA). Because every principal who wants to interact with a blockchain needs an identity, you might say that **a CA defines an organization from a digital perspective**. It's the CA that provides the basis for an organization's principals to have a verifiable identity, expressed as a digital certificate.

If you're interested, you can read a lot more about CAs [here](./), but for now you should think of them as the components who issue digital certificates that convey a principal's identity in the network and their membership of a given organization.

### Root CAs and Intermediate CAs

CAs come in two flavors: **Root CAs** and **Intermediate CAs**. Because Root CAs (Symantec, Geotrust, etc) have to **securely distribute** hundreds of millions of certificates to internet users, it makes sense to spread this process out across what are called **Intermediate CAs**. These Intermediate CAs provide their certificates under the authority of the Root CA, and this linkage between a Root CA and Intermediate CAs establishes a **Chain of Trust** for any certificate that is issued by any CA in the chain. This ability to track back to the Root CA not only allows the function of CAs to scale while  still providing security -- allowing organizations that consume certificates to use Intermediate CAs with confidence -- it limits the exposure of the Root CA, which, if compromised, would destroy the entire chain of trust. If an Intermediate CA is compromised, on the other hand, there is a much smaller exposure.

| ![ChainOfTrust](./IdentityandChainsofTrust.diagram.1.png) |
| :---: |
| A chain of trust is established between a Root CA and a set of Intermediate CAs using a simple chain. Many other configurations are possible to meet the needs of collaborating organizations. |

Intermediate CAs provide a huge amount of flexibility when it comes to the issuance of certificates across multiple organizations, and that's very helpful for a permissioned blockchain. For example, you'll see that different organizations may use different Root CAs, or the same Root CA with different Intermediate CAs -- it really does depend on the needs of the network.

### Fabric CA

It's because CAs are so important that Hyperledger Fabric provides a built-in CA component to allow you to create CAs in the blockchain networks you form. You don't have to use the Fabric CA, but you will find it very helpful when you're starting to build a blockchain network for the first time, or using the [DRIVENET sample network](./).  

A Fabric CA is not as sophisticated as a full CA, but that's OK -- it's sufficient for many purposes. As you'll see, there are a few limitations to a Fabric CA. You can read more about these restrictions in the [Fabric CA reference section](../ReferenceMaterial/FabricCA.md)

## Membership Services Providers

You've now seen how CAs can provide verifiable identities through a chain of trust, so let's now see **how the identity is recognized**. That's where Membership Services Providers (MSPs) come into play.

Whereas a CA provides a verifiable identity, an MSP complements this by identifying which Root CAs and Intermediate CAs are recognized. An MSP can also recognize other things related to identity -- a list identities that have been revoked, for example -- but those things will be covered later. For now, **think of an MSP as providing a recognition list for CAs**.

| ![MSPs](./IdentityandChainsofTrust.diagram.2.png) |
| :---: |
| A simplified configuration is shown here where the Network, Channel, Orderer and Peer only recognize identities issued by RCA1, RCA2, ICA1 and ICA2 respectively.  Network and channel MSPs are global, whereas peer and orderer MSPs are local. |

### Local and Global MSPs

There are two different types of MSPs: local and global. **Local MSPs are only defined for nodes** (peer or orderer) and they apply to the node where they are defined. Moreover, every node must have a local MSP defined. In contrast, **global MSPs are only defined for channels or the entire network**, and they apply to all of the nodes that are part of a channel or network. Every channel or network must have an MSP defined for it. This means that peers and orderers in the same channel or network all share the same global MSP. In summary, you can see that the difference between local and global MSPs is the scope to which the MSP applies.  

You'll also see that local MSPs are defined on the file system of the peer or orderer to which they apply. Therefore, physically and logically there is only one local MSP per node. However, as global MSPs apply to all nodes in a channel or network, they are defined once inside the network or channel configuration. Physically there are multiple copies of a global MSP, because it is replicated across every node and kept synchronized via consensus, but logically there is only one global MSP per channel or network.

### MSP Levels

As you've seen, MSPs provide a list of recognized CAs -- for peers and orderers these are called local MSPs, and for channels and networks they are called global MSPs.  It's helpful to think of these MSPs at being at different **levels** -- **MSPs at a higher level relate to network-wide administration concerns, whereas MSPs at a lower level are limited to administration of private resources**. This tiering is helpful because it supports the mix of both broad and narrow administrative control depending on how the network is constituted. MSPs are mandatory -- they must be defined for each of the four levels: Network, Channel, Peer and Orderer.

 * **Network MSP:** These MSPs are defined in the configuration policy of the whole network, so by definition, **there is only one network MSP**. Every principal who uses a network configuration must have their identity recognized by this MSP before they can perform an administrative task at the network level. This means that the CAs that are defined by the network MSP should **recognize the organizations who have overall administrative control over the whole network**. An example of a network-wide administrative permission might be to define or change the organizations who can create channels.

 * **Channel MSP:** These MSPs are defined inside the configuration policy of each channel, and therefore there is one MSP for each channel that is defined. It is helpful for a channel to have its own MSP because a channel provides private communications between a particular set of organizations and its MSP identifies the organizations that have administrative control over it. You can see that the need for **a separate channel MSP stems from the need for local autonomy** -- the organizations in a channel can be largely independent from the rest of the network. It also means that administrative control over the network doesn't necessarily imply control over any particular channel; again reflecting the real administrative needs of collaborating organizations who may sometimes require separation of control. We see this kind of separation at the levels of control in the real world, too. The authority of the President of the United States, for example, exists at the federal level. He or she has no authority to veto state laws.

 * **Peer MSP:** These MSPs are defined on the local file system of each peer. Conceptually, they perform exactly the same function as global MSPs with the restriction that they only apply to the peer where they are defined. As peers are owned by a particular organization and connect applications from that organization to the ledger, the MSP for a peer usually refers to identity information from that organization only. It's possible to specify multiple different CAs in a peer MSP, it's just that in practice a local MSP refers to fewer CAs than a global MSP. An example of a peer permission might be the ability to install or upgrade smart contract chaincode on that peer.

 * **Orderer MSP:** Like peer MSPs, orderer MSPs are also defined on the local file system of the orderer and only apply to it. Like peer nodes, orderer nodes are also owned by a single organization and therefore their MSPs typically recognize a single organization's identity information, though again it's possible to specify others organizations. There are a currently very few, if any,   administrative actions that are local to an orderer node, so in reality and orderer may not need to populate its local MSP.

### Up to here

### MSP Detailed Structure

As you've seen, an MSP defines allows different components in a blockchain network to recognized different identity providers.  

 * **Root CAs**

 * **Intermediate CAs**

 * **Certificate Revocation List (CRL)**

 * **Sign Cert** (public cert/pem file)

 * **KeyStore** Private key

 * **TLS Root CA**

 * **TLS Intermediate CA**

 * **TLS Certificate Revocation List (CRL)**

 * **TLS SignCert**

 * **Administrators (Local MSP only)**

### Remainder material to be incorporated

So far, so good  -

well-known authorities who are the key parts of the internet, they provide  

 Network and Channel MSPs are global -- they control the behaviour of all nodes who interact with them.  Peer and Orderer MSPs are local -- they only control behaviour for the nodes where they are defined.  

Nothing about a Fabric network can function unless components trust each other's identities and the permissions those identities entitle them to. Establishing that trust means creating *digital certificates* which can be verified against a shared trust store of identities.

Those certificates are created by a component we call a Certificate Authority (CA) using public keys (which are self-generated from a component -- or user's -- public/private keys).

This is not dissimilar from how identity works in the real world. Think of your private key as being roughly analogous to a Social Security Number. It's too dangerous to expose directly as a regular form of identity, but it can be used to generate other identities -- a driver's license, for example -- which is issued by a trusted source (the DMV). This driver's license is like your public key -- still private, but used to grant permissions (like the right to drive) and to generate other identities (like a library card).

In a Fabric network, the CA -- which is trusted by the network -- takes the place of the DMV and issues you a digital cert. And just as the driver's license is used as a proxy for identity (while also conferring explicit privileges like the right to drive), the digital certs issued by a CA confer not just identity but rights to perform network functions or over network components.


You're now going to focus on four components the blockchain, and how they establish a **chain of trust** in order to help them determine which principals have permission over different network resources. As you saw in [](./),
In this topic, Four of the components in the network are

In this topic you'll see how **a chain of trust** must be established by four of the major components in a blockchain network -- the peers, orderers, channels and the network itself.

 -- they need to establish a chain of trust for the principals who wish to interact with these components.  

We  

For example, if a peer wants to determine whether a connected application can update a ledger, it uses the channel policy to look up the permission associated with the application's organization.

is a digital certificate which holds

As you've also seen, an identity is brought to the network by a principal in the form of a cryptographically validated digital certificate issued by a Certificate Authority.  Ad as we've seen, a Hyperledger Fabric blockhain network can only function when components trust principal's identities. There are two parts to establishing trust, specifically **digital certificates** and the identification of which can be verified against a shared trust store of identities.

*(Other things I'm not sure about: How are you brought into the network originally (how are those certs generated, from where, where are they stored, what happens to them). And then how are they used by you in two different ways: 1) to execute certain functions. How are they tested? Who tests them? Where do they test them? What exact identity are you using (is it a global ID or does it just go back to the root CA to check it). And 2) how is this identity used to get new privileges and how and where is that update stored (such that it can be checked out when you want to perform that action)).*

## MSPs in DRIVENET


[Next: Policies for Access Control](./PoliciesforAccessControl.md)
